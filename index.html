<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Edu-Puzzle Maker - 단어 찾기 퍼즐</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Jua&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Noto Sans KR', sans-serif; }
    .app-container {
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      position: relative;
      overflow-x: hidden;
    }
    .app-container::before {
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-image: 
        radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255,255,255,0.15) 0%, transparent 50%);
      pointer-events: none;
    }
    .home-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      position: relative;
      z-index: 1;
    }
    .logo-container { text-align: center; margin-bottom: 3rem; }
    .logo-icon { font-size: 5rem; margin-bottom: 1rem; animation: bounce 2s ease-in-out infinite; }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }
    .main-title {
      font-family: 'Jua', sans-serif;
      font-size: 3.5rem;
      color: #fff;
      text-shadow: 4px 4px 0 rgba(0,0,0,0.2);
      margin-bottom: 0.5rem;
    }
    .subtitle { font-size: 1.3rem; color: rgba(255,255,255,0.9); }
    .home-buttons { display: flex; gap: 2rem; margin-bottom: 3rem; }
    .home-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 3rem;
      border: none;
      border-radius: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    .create-btn { background: linear-gradient(135deg, #FFD93D 0%, #FF6B6B 100%); }
    .home-btn:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 15px 40px rgba(0,0,0,0.3); }
    .btn-icon { font-size: 3rem; margin-bottom: 0.5rem; }
    .btn-text { font-family: 'Jua', sans-serif; font-size: 1.5rem; color: #333; }
    .btn-desc { font-size: 0.9rem; color: rgba(0,0,0,0.6); margin-top: 0.3rem; }
    .home-features { display: flex; gap: 2rem; flex-wrap: wrap; justify-content: center; }
    .feature {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(255,255,255,0.2);
      backdrop-filter: blur(10px);
      padding: 1rem 1.5rem;
      border-radius: 50px;
      color: #fff;
      font-size: 1rem;
    }
    .create-screen {
      min-height: 100vh;
      padding: 2rem;
      max-width: 700px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    .back-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: #fff;
      padding: 0.8rem 1.5rem;
      border-radius: 50px;
      cursor: pointer;
      font-size: 1rem;
      margin-bottom: 2rem;
      transition: all 0.3s ease;
    }
    .back-btn:hover { background: rgba(255,255,255,0.3); }
    .screen-title {
      font-family: 'Jua', sans-serif;
      font-size: 2.5rem;
      color: #fff;
      text-align: center;
      margin-bottom: 2rem;
      text-shadow: 3px 3px 0 rgba(0,0,0,0.2);
    }
    .form-group { margin-bottom: 1.5rem; }
    .form-group label {
      display: block;
      color: #fff;
      font-weight: 700;
      margin-bottom: 0.5rem;
      font-size: 1.1rem;
    }
    .text-input, .words-input {
      width: 100%;
      padding: 1rem 1.5rem;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 16px;
      font-size: 1.1rem;
      background: rgba(255,255,255,0.95);
      font-family: 'Noto Sans KR', sans-serif;
      transition: all 0.3s ease;
    }
    .text-input:focus, .words-input:focus {
      outline: none;
      border-color: #FFD93D;
      box-shadow: 0 0 20px rgba(255,217,61,0.4);
    }
    .words-input { resize: vertical; min-height: 200px; }
    .input-instructions {
      background: rgba(255,255,255,0.15);
      padding: 1rem;
      border-radius: 12px;
      margin-bottom: 1rem;
      color: #fff;
    }
    .input-instructions p {
      margin-bottom: 0.3rem;
      font-size: 0.95rem;
    }
    .key-hint {
      background: rgba(255,255,255,0.3);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.85rem;
    }
    .word-pairs-container {
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      padding: 1rem;
      margin-bottom: 1rem;
      max-height: 400px;
      overflow-y: auto;
    }
    .word-pair-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.8rem;
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 10px;
      transition: all 0.2s ease;
    }
    .word-pair-row:hover {
      background: #f0f0f0;
    }
    .word-pair-row:last-child {
      margin-bottom: 0;
    }
    .pair-number {
      font-family: 'Jua', sans-serif;
      font-size: 1rem;
      color: #667eea;
      min-width: 24px;
      text-align: center;
    }
    .word-input {
      flex: 1;
      padding: 0.7rem 1rem;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
      font-family: 'Noto Sans KR', sans-serif;
      transition: all 0.2s ease;
    }
    .word-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102,126,234,0.2);
    }
    .english-input {
      background: #fff;
    }
    .korean-input {
      background: #fffbeb;
    }
    .arrow-divider {
      color: #667eea;
      font-size: 1.2rem;
      font-weight: bold;
    }
    .remove-pair-btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 50%;
      background: #ff6b6b;
      color: #fff;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .remove-pair-btn:hover:not(:disabled) {
      background: #ee5a5a;
      transform: scale(1.1);
    }
    .remove-pair-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .add-pair-btn {
      width: 100%;
      padding: 0.8rem;
      border: 2px dashed #667eea;
      border-radius: 10px;
      background: rgba(102,126,234,0.1);
      color: #667eea;
      font-family: 'Jua', sans-serif;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .add-pair-btn:hover {
      background: rgba(102,126,234,0.2);
      border-style: solid;
    }
    .word-count {
      text-align: right;
      color: rgba(255,255,255,0.8);
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }
    .input-hint { color: rgba(255,255,255,0.8); font-size: 0.9rem; margin-top: 0.5rem; }
    .difficulty-selector { display: flex; gap: 1rem; }
    .diff-btn {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 16px;
      background: rgba(255,255,255,0.1);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .diff-btn.active { background: rgba(255,255,255,0.95); border-color: #FFD93D; }
    .diff-icon { font-size: 2.5rem; margin-bottom: 0.5rem; }
    .diff-name { font-family: 'Jua', sans-serif; font-size: 1.3rem; color: #333; }
    .diff-desc { font-size: 0.85rem; color: #666; margin-top: 0.3rem; }
    .diff-btn:not(.active) .diff-name, .diff-btn:not(.active) .diff-desc { color: rgba(255,255,255,0.9); }
    .generate-btn {
      width: 100%;
      padding: 1.2rem;
      border: none;
      border-radius: 16px;
      background: linear-gradient(135deg, #FFD93D 0%, #FF6B6B 100%);
      color: #333;
      font-family: 'Jua', sans-serif;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    }
    .generate-btn:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
    .url-result {
      margin-top: 2rem;
      background: rgba(255,255,255,0.95);
      border-radius: 20px;
      padding: 2rem;
      text-align: center;
    }
    .url-result h3 {
      font-family: 'Jua', sans-serif;
      font-size: 1.5rem;
      color: #333;
      margin-bottom: 1.5rem;
    }
    .result-section {
      text-align: left;
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid #eee;
    }
    .result-section label {
      display: block;
      font-weight: 700;
      color: #333;
      margin-bottom: 0.5rem;
    }
    .url-box { display: flex; gap: 0.5rem; }
    .url-input {
      flex: 1;
      padding: 0.8rem;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 0.9rem;
    }
    .copy-btn {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 10px;
      background: #667eea;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .copy-btn:hover { background: #5a6fd6; }
    .action-buttons { display: flex; gap: 1rem; justify-content: center; margin-top: 1rem; }
    .preview-btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      background: linear-gradient(135deg, #6BCB77 0%, #4D96FF 100%);
      color: #fff;
      font-family: 'Jua', sans-serif;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .preview-btn:hover { transform: translateY(-2px); }
    .play-screen {
      min-height: 100vh;
      padding: 1.5rem;
      padding-bottom: 100px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      z-index: 1;
    }
    .play-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 550px;
      margin-bottom: 1rem;
    }
    .puzzle-title {
      font-family: 'Jua', sans-serif;
      font-size: 1.8rem;
      color: #fff;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
    }
    .timer {
      background: rgba(255,255,255,0.95);
      padding: 0.6rem 1.2rem;
      border-radius: 50px;
      font-family: 'Jua', sans-serif;
      font-size: 1.3rem;
      color: #333;
    }
    .grid-wrapper { width: 100%; display: flex; justify-content: center; padding: 0 1rem; }
    .grid-container {
      display: grid;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 10px;
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      user-select: none;
      touch-action: none;
      gap: 3px;
      aspect-ratio: 1;
    }
    .grid-container.size-10 { width: min(90vw, 450px); }
    .grid-container.size-15 { width: min(95vw, 550px); gap: 2px; padding: 8px; }
    .grid-container.shake { animation: shake 0.3s ease; }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    .grid-cell {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.95);
      border-radius: 4px;
      font-family: 'Jua', sans-serif;
      font-weight: 700;
      color: #333;
      cursor: pointer;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .grid-container.size-10 .grid-cell { font-size: clamp(1rem, 4vw, 1.5rem); }
    .grid-container.size-15 .grid-cell { font-size: clamp(0.7rem, 2.2vw, 1rem); border-radius: 3px; }
    .grid-cell:hover { background: rgba(255,255,255,1); transform: scale(1.02); }
    .grid-cell.selected {
      background: linear-gradient(135deg, #4D96FF 0%, #3a7bd5 100%);
      color: #fff;
      transform: scale(1.08);
      box-shadow: 0 4px 12px rgba(77,150,255,0.5);
      z-index: 1;
    }
    .grid-cell.found { color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    .section-box {
      margin-top: 1.5rem;
      background: rgba(255,255,255,0.95);
      padding: 1.5rem;
      border-radius: 20px;
      width: 100%;
      max-width: 550px;
    }
    .section-box h3 {
      font-family: 'Jua', sans-serif;
      font-size: 1.3rem;
      color: #333;
      margin-bottom: 1rem;
      text-align: center;
    }
    .words {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      justify-content: center;
    }
    .word-item {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      padding: 0.5rem 1rem;
      border-radius: 50px;
      font-family: 'Jua', sans-serif;
      font-size: 1.1rem;
      transition: all 0.3s ease;
    }
    .word-item.found { background: #6BCB77; text-decoration: line-through; opacity: 0.7; }
    .matching-row {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
      padding: 0.8rem;
      background: #f8f9fa;
      border-radius: 12px;
      transition: all 0.3s ease;
    }
    .matching-row.correct { background: #d4edda; border: 2px solid #6BCB77; }
    .matching-row.incorrect { background: #f8d7da; border: 2px solid #FF6B6B; }
    .english-word {
      flex: 1;
      font-family: 'Jua', sans-serif;
      font-size: 1.2rem;
      padding: 0.5rem 1rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-radius: 10px;
      text-align: center;
    }
    .arrow-icon { font-size: 1.5rem; color: #666; }
    .meaning-select {
      flex: 1.5;
      padding: 0.8rem 1rem;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 1rem;
      font-family: 'Noto Sans KR', sans-serif;
      background: #fff;
      cursor: pointer;
    }
    .meaning-select:focus { outline: none; border-color: #667eea; }
    .meaning-select.correct { border-color: #6BCB77; background: #d4edda; }
    .meaning-select.incorrect { border-color: #FF6B6B; background: #f8d7da; }
    .correct-answer { font-size: 0.85rem; color: #6BCB77; margin-top: 0.3rem; font-weight: 700; width: 100%; }
    .submit-section {
      margin-top: 2rem;
      width: 100%;
      max-width: 550px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    .submit-btn {
      width: 100%;
      padding: 1.2rem;
      border: none;
      border-radius: 16px;
      background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
      color: #333;
      font-family: 'Jua', sans-serif;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    }
    .submit-btn:hover { transform: translateY(-3px); }
    .submit-btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
    .incomplete-warning {
      color: #FFD93D;
      font-weight: 700;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .result-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
      padding: 1rem;
    }
    .result-content {
      background: #fff;
      padding: 2rem;
      border-radius: 30px;
      text-align: center;
      animation: popIn 0.5s ease;
      max-width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      width: 400px;
    }
    .result-icon { font-size: 5rem; margin-bottom: 1rem; }
    .result-content h2 { font-family: 'Jua', sans-serif; font-size: 2rem; color: #333; }
    .result-score { font-family: 'Jua', sans-serif; font-size: 1.5rem; color: #667eea; margin: 1rem 0; }
    .result-details {
      text-align: left;
      background: #f8f9fa;
      padding: 1rem;
      border-radius: 12px;
      margin: 1rem 0;
    }
    .result-details p { margin-bottom: 0.5rem; }
    .wrong-list { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ddd; }
    .wrong-list h4 { color: #FF6B6B; margin-bottom: 0.5rem; }
    .wrong-item {
      background: #fff;
      padding: 0.5rem;
      border-radius: 8px;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      border-left: 3px solid #FF6B6B;
    }
    .result-buttons { display: flex; gap: 1rem; justify-content: center; margin-top: 1.5rem; flex-wrap: wrap; }
    .retry-btn, .play-again-btn, .home-btn-small {
      padding: 1rem 2rem;
      border: none;
      border-radius: 50px;
      font-family: 'Jua', sans-serif;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .retry-btn { background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%); color: #333; }
    .play-again-btn { background: linear-gradient(135deg, #6BCB77 0%, #4D96FF 100%); color: #fff; }
    .home-btn-small { background: linear-gradient(135deg, #764ba2 0%, #667eea 100%); color: #fff; }
    .retry-btn:hover, .play-again-btn:hover, .home-btn-small:hover { transform: translateY(-3px); }
    .reset-btn {
      margin-top: 1.5rem;
      padding: 1rem 2rem;
      border: none;
      border-radius: 50px;
      background: rgba(255,255,255,0.2);
      color: #fff;
      font-family: 'Jua', sans-serif;
      font-size: 1.1rem;
      cursor: pointer;
    }
    .reset-btn:hover { background: rgba(255,255,255,0.3); }
    .status-badge {
      display: inline-block;
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 700;
      margin-left: 0.5rem;
    }
    .status-badge.complete { background: #6BCB77; color: #fff; }
    .status-badge.incomplete { background: #FFD93D; color: #333; }
    .teacher-controls {
      width: 100%;
      max-width: 550px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255,255,255,0.95);
      padding: 0.8rem 1.2rem;
      border-radius: 12px;
      margin-bottom: 1rem;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    .teacher-badge {
      font-family: 'Jua', sans-serif;
      font-size: 1rem;
      color: #667eea;
      background: #f0f0ff;
      padding: 0.4rem 0.8rem;
      border-radius: 20px;
    }
    .teacher-buttons {
      display: flex;
      gap: 0.5rem;
    }
    .answer-toggle-btn {
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      font-family: 'Jua', sans-serif;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .answer-toggle-btn:hover {
      transform: scale(1.05);
    }
    .answer-toggle-btn.active {
      background: linear-gradient(135deg, #6BCB77 0%, #4D96FF 100%);
    }
    .back-to-create-btn {
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 20px;
      background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
      color: #333;
      font-family: 'Jua', sans-serif;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .back-to-create-btn:hover {
      transform: scale(1.05);
    }
    .matching-row.show-answer {
      background: #f0f8ff;
      border: 2px dashed #667eea;
    }
    .confetti-container {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 999;
      overflow: hidden;
    }
    .confetti-piece {
      position: absolute;
      width: 10px; height: 10px;
      top: -20px;
      animation: confettiFall linear forwards;
    }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes popIn {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    .loading {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 1.5rem;
    }
    @media (max-width: 600px) {
      .main-title { font-size: 2.5rem; }
      .home-buttons { flex-direction: column; }
      .home-btn { padding: 1.5rem 2rem; }
      .home-features { flex-direction: column; align-items: center; }
      .difficulty-selector { flex-direction: column; }
      .grid-container { padding: 6px; gap: 2px; }
      .grid-container.size-10 .grid-cell { font-size: clamp(0.9rem, 3.5vw, 1.3rem); }
      .grid-container.size-15 .grid-cell { font-size: clamp(0.6rem, 2vw, 0.85rem); }
      .play-header { flex-direction: column; gap: 0.5rem; text-align: center; }
      .puzzle-title { font-size: 1.5rem; }
      .result-content { padding: 1.5rem; }
      .result-buttons { flex-direction: column; }
      .matching-row { flex-direction: column; gap: 0.5rem; }
      .english-word, .meaning-select { width: 100%; flex: none; }
      .arrow-icon { transform: rotate(90deg); }
      .teacher-controls { flex-direction: column; gap: 0.5rem; text-align: center; }
      .teacher-buttons { flex-direction: column; width: 100%; }
      .teacher-buttons button { width: 100%; }
      .word-pair-row { flex-wrap: wrap; }
      .word-input { min-width: 100px; }
      .arrow-divider { display: none; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // LZString 압축 라이브러리 (인라인)
    const LZString = (function() {
      const f = String.fromCharCode;
      const keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      const keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      const baseReverseDic = {};
      
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (let i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      
      function _compress(uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null) return "";
        let i, value, context_dictionary = {}, context_dictionaryToCreate = {},
            context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2,
            context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0,
            context_data_position = 0;
        
        for (let ii = 0; ii < uncompressed.length; ii++) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = (context_data_val << 1);
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else { context_data_position++; }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = (context_data_val << 1) | (value & 1);
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else { context_data_position++; }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = (context_data_val << 1) | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else { context_data_position++; }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = (context_data_val << 1) | (value & 1);
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else { context_data_position++; }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else { context_data_position++; }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        if (context_w !== "") {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1);
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else { context_data_position++; }
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else { context_data_position++; }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else { context_data_position++; }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else { context_data_position++; }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else { context_data_position++; }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) { context_numBits++; }
        }
        value = 2;
        for (i = 0; i < context_numBits; i++) {
          context_data_val = (context_data_val << 1) | (value & 1);
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else { context_data_position++; }
          value = value >> 1;
        }
        while (true) {
          context_data_val = (context_data_val << 1);
          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else { context_data_position++; }
        }
        return context_data.join('');
      }
      
      function _decompress(length, resetValue, getNextValue) {
        let dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3,
            entry = "", result = [], i, w, c, resb,
            data = { val: getNextValue(0), position: resetValue, index: 1 };
        for (i = 0; i < 3; i++) { dictionary[i] = i; }
        let bits = 0, maxpower = Math.pow(2, 2), power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) { data.position = resetValue; data.val = getNextValue(data.index++); }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        const next = bits;
        switch (next) {
          case 0: bits = 0; maxpower = Math.pow(2, 8); power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) { data.position = resetValue; data.val = getNextValue(data.index++); }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f(bits); break;
          case 1: bits = 0; maxpower = Math.pow(2, 16); power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) { data.position = resetValue; data.val = getNextValue(data.index++); }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f(bits); break;
          case 2: return "";
        }
        dictionary[3] = c;
        w = c;
        result.push(c);
        while (true) {
          if (data.index > length) return "";
          bits = 0; maxpower = Math.pow(2, numBits); power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) { data.position = resetValue; data.val = getNextValue(data.index++); }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (c = bits) {
            case 0: bits = 0; maxpower = Math.pow(2, 8); power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) { data.position = resetValue; data.val = getNextValue(data.index++); }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 1: bits = 0; maxpower = Math.pow(2, 16); power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) { data.position = resetValue; data.val = getNextValue(data.index++); }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 2: return result.join('');
          }
          if (enlargeIn == 0) { enlargeIn = Math.pow(2, numBits); numBits++; }
          if (dictionary[c]) { entry = dictionary[c]; }
          else { if (c === dictSize) { entry = w + w.charAt(0); } else { return null; } }
          result.push(entry);
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          if (enlargeIn == 0) { enlargeIn = Math.pow(2, numBits); numBits++; }
          w = entry;
        }
      }
      
      return {
        compressToEncodedURIComponent: function(input) {
          if (input == null) return "";
          return _compress(input, 6, function(a) { return keyStrUriSafe.charAt(a); });
        },
        decompressFromEncodedURIComponent: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          input = input.replace(/ /g, "+");
          return _decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
        }
      };
    })();

    const encodeData = (data) => {
      try {
        const jsonStr = JSON.stringify(data);
        return LZString.compressToEncodedURIComponent(jsonStr);
      } catch (e) { return null; }
    };

    const decodeData = (encoded) => {
      try {
        // 새 압축 방식 시도
        const decompressed = LZString.decompressFromEncodedURIComponent(encoded);
        if (decompressed) {
          return JSON.parse(decompressed);
        }
        // 이전 방식 호환 (Base64)
        let base64 = encoded.replace(/-/g, '+').replace(/_/g, '/');
        while (base64.length % 4) base64 += '=';
        const binaryStr = atob(base64);
        const utf8Bytes = new Uint8Array(binaryStr.split('').map(char => char.charCodeAt(0)));
        return JSON.parse(new TextDecoder().decode(utf8Bytes));
      } catch (e) { return null; }
    };

    const shuffleArray = (arr) => {
      const s = [...arr];
      for (let i = s.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [s[i], s[j]] = [s[j], s[i]];
      }
      return s;
    };

    const generateWordSearchGrid = (words, gridSize, allowDiagonal, allowReverse) => {
      const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(''));
      const placements = [];
      const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }];
      if (allowDiagonal) directions.push({ dx: 1, dy: 1 }, { dx: 1, dy: -1 });

      const canPlace = (word, sx, sy, dx, dy) => {
        for (let i = 0; i < word.length; i++) {
          const x = sx + i * dx, y = sy + i * dy;
          if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return false;
          if (grid[y][x] !== '' && grid[y][x] !== word[i]) return false;
        }
        return true;
      };

      const placeWord = (word, sx, sy, dx, dy) => {
        const cells = [];
        for (let i = 0; i < word.length; i++) {
          const x = sx + i * dx, y = sy + i * dy;
          grid[y][x] = word[i];
          cells.push({ x, y });
        }
        return cells;
      };

      const englishWords = words.map(w => w.english.toUpperCase());
      [...englishWords].sort((a, b) => b.length - a.length).forEach(word => {
        let placed = false, attempts = 0;
        while (!placed && attempts < 100) {
          const shouldReverse = allowReverse && Math.random() > 0.5;
          const w = shouldReverse ? word.split('').reverse().join('') : word;
          const dir = directions[Math.floor(Math.random() * directions.length)];
          const sx = Math.floor(Math.random() * gridSize);
          const sy = Math.floor(Math.random() * gridSize);
          if (canPlace(w, sx, sy, dir.dx, dir.dy)) {
            placements.push({ word, cells: placeWord(w, sx, sy, dir.dx, dir.dy), reversed: shouldReverse });
            placed = true;
          }
          attempts++;
        }
      });

      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let y = 0; y < gridSize; y++)
        for (let x = 0; x < gridSize; x++)
          if (grid[y][x] === '') grid[y][x] = chars[Math.floor(Math.random() * 26)];

      return { grid, placements };
    };

    const Confetti = ({ active }) => {
      if (!active) return null;
      const pieces = Array(50).fill(null).map((_, i) => ({
        id: i, left: Math.random() * 100, delay: Math.random() * 2, duration: 2 + Math.random() * 2,
        color: ['#FFD93D', '#6BCB77', '#4D96FF', '#FF6B6B', '#C9B1FF'][Math.floor(Math.random() * 5)]
      }));
      return (
        <div className="confetti-container">
          {pieces.map(p => (
            <div key={p.id} className="confetti-piece" style={{
              left: `${p.left}%`, animationDelay: `${p.delay}s`,
              animationDuration: `${p.duration}s`, backgroundColor: p.color
            }} />
          ))}
        </div>
      );
    };

    function EduPuzzleMaker() {
      const [mode, setMode] = useState('home');
      const [puzzleData, setPuzzleData] = useState(null);
      const [title, setTitle] = useState('');
      const [wordsInput, setWordsInput] = useState('');
      const [difficulty, setDifficulty] = useState('easy');
      const [generatedUrl, setGeneratedUrl] = useState('');
      const [baseUrl, setBaseUrl] = useState('');
      const [puzzleCode, setPuzzleCode] = useState('');
      const [wordPairs, setWordPairs] = useState([{ english: '', korean: '' }]);
      const [grid, setGrid] = useState([]);
      const [placements, setPlacements] = useState([]);
      const [foundWords, setFoundWords] = useState([]);
      const [selecting, setSelecting] = useState(false);
      const [selectedCells, setSelectedCells] = useState([]);
      const [startCell, setStartCell] = useState(null);
      const [timer, setTimer] = useState(0);
      const [isTimerRunning, setIsTimerRunning] = useState(false);
      const [wrongSelection, setWrongSelection] = useState(false);
      const [matchingAnswers, setMatchingAnswers] = useState({});
      const [shuffledMeanings, setShuffledMeanings] = useState([]);
      const [showResult, setShowResult] = useState(false);
      const [resultData, setResultData] = useState(null);
      const [checkedAnswers, setCheckedAnswers] = useState({});
      const [isPreviewMode, setIsPreviewMode] = useState(false);
      const [showAnswers, setShowAnswers] = useState(false);
      const gridRef = useRef(null);

      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const data = params.get('puzzle');
        if (data) {
          const decoded = decodeData(data);
          if (decoded) { setPuzzleData(decoded); setMode('play'); setIsPreviewMode(false); }
        }
        setBaseUrl(window.location.origin + window.location.pathname);
      }, []);

      useEffect(() => {
        if (puzzleData && mode === 'play') {
          const { words, gridSize, allowDiagonal, allowReverse, savedGrid, savedPlacements } = puzzleData;
          
          // 저장된 그리드가 있으면 사용, 없으면 새로 생성 (이전 버전 호환)
          let g, p;
          if (savedGrid && savedPlacements) {
            g = savedGrid;
            p = savedPlacements;
          } else {
            const result = generateWordSearchGrid(words, gridSize, allowDiagonal, allowReverse);
            g = result.grid;
            p = result.placements;
          }
          
          setGrid(g); setPlacements(p); setFoundWords([]); setTimer(0);
          setIsTimerRunning(true); setMatchingAnswers({}); setCheckedAnswers({});
          setShowResult(false); setShuffledMeanings(shuffleArray(words.map(w => w.korean)));
        }
      }, [puzzleData, mode]);

      useEffect(() => {
        let interval;
        if (isTimerRunning) interval = setInterval(() => setTimer(t => t + 1), 1000);
        return () => clearInterval(interval);
      }, [isTimerRunning]);

      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

      const generatePuzzle = () => {
        const words = wordPairs
          .filter(pair => pair.english.trim() && pair.korean.trim())
          .filter(pair => /^[a-zA-Z]+$/.test(pair.english.trim()))
          .map(pair => ({ english: pair.english.trim(), korean: pair.korean.trim() }))
          .slice(0, 15);
        
        if (words.length === 0) { alert('유효한 단어를 입력해주세요!\n영어 단어는 알파벳만 입력 가능합니다.'); return; }
        const gridSize = difficulty === 'easy' ? 10 : 15;
        const allowDiagonal = difficulty === 'hard';
        const allowReverse = difficulty === 'hard';
        
        const { grid: generatedGrid, placements: generatedPlacements } = generateWordSearchGrid(words, gridSize, allowDiagonal, allowReverse);
        
        const data = { 
          title: title || '영어 단어 학습', 
          words, 
          gridSize, 
          allowDiagonal, 
          allowReverse,
          savedGrid: generatedGrid,
          savedPlacements: generatedPlacements
        };
        const encoded = encodeData(data);
        setPuzzleCode(encoded);
        if (baseUrl) setGeneratedUrl(`${baseUrl.replace(/\/$/, '')}?puzzle=${encoded}`);
      };
      
      const updateWordPair = (index, field, value) => {
        const newPairs = [...wordPairs];
        newPairs[index][field] = value;
        setWordPairs(newPairs);
      };
      
      const addWordPair = () => {
        if (wordPairs.length < 15) {
          setWordPairs([...wordPairs, { english: '', korean: '' }]);
        }
      };
      
      const removeWordPair = (index) => {
        if (wordPairs.length > 1) {
          const newPairs = wordPairs.filter((_, i) => i !== index);
          setWordPairs(newPairs);
        }
      };
      
      const handleKeyDown = (e, index, field) => {
        if (e.key === ' ' && field === 'english') {
          e.preventDefault();
          const koreanInput = document.getElementById(`korean-${index}`);
          if (koreanInput) koreanInput.focus();
        } else if (e.key === ' ' && field === 'korean' && e.target.value.trim()) {
          e.preventDefault();
          if (index === wordPairs.length - 1 && wordPairs.length < 15) {
            addWordPair();
            setTimeout(() => {
              const nextEnglish = document.getElementById(`english-${index + 1}`);
              if (nextEnglish) nextEnglish.focus();
            }, 50);
          } else if (index < wordPairs.length - 1) {
            const nextEnglish = document.getElementById(`english-${index + 1}`);
            if (nextEnglish) nextEnglish.focus();
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (field === 'english') {
            const koreanInput = document.getElementById(`korean-${index}`);
            if (koreanInput) koreanInput.focus();
          } else if (field === 'korean') {
            if (index === wordPairs.length - 1 && wordPairs.length < 15) {
              addWordPair();
              setTimeout(() => {
                const nextEnglish = document.getElementById(`english-${index + 1}`);
                if (nextEnglish) nextEnglish.focus();
              }, 50);
            } else if (index < wordPairs.length - 1) {
              const nextEnglish = document.getElementById(`english-${index + 1}`);
              if (nextEnglish) nextEnglish.focus();
            }
          }
        }
      };

      const copyUrl = () => { navigator.clipboard.writeText(generatedUrl); alert('링크가 복사되었습니다!'); };

      const getCellsInLine = (start, end) => {
        if (!start || !end) return [];
        const dx = Math.sign(end.x - start.x), dy = Math.sign(end.y - start.y);
        if (dx !== 0 && dy !== 0 && Math.abs(end.x - start.x) !== Math.abs(end.y - start.y)) return [start];
        const cells = [];
        let x = start.x, y = start.y;
        while (true) { cells.push({ x, y }); if (x === end.x && y === end.y) break; x += dx; y += dy; if (cells.length > 20) break; }
        return cells;
      };

      const handleCellMouseDown = (x, y) => { setSelecting(true); setStartCell({ x, y }); setSelectedCells([{ x, y }]); setWrongSelection(false); };
      const handleCellMouseEnter = (x, y) => { if (selecting && startCell) setSelectedCells(getCellsInLine(startCell, { x, y })); };
      const handleMouseUp = () => {
        if (selecting && selectedCells.length > 1) {
          const word = selectedCells.map(c => grid[c.y][c.x]).join('');
          const rev = word.split('').reverse().join('');
          const match = placements.find(p => (word === p.word || rev === p.word) && !foundWords.includes(p.word));
          if (match) setFoundWords([...foundWords, match.word]);
          else { setWrongSelection(true); setTimeout(() => setWrongSelection(false), 300); }
        }
        setSelecting(false); setSelectedCells([]); setStartCell(null);
      };

      const isCellSelected = (x, y) => selectedCells.some(c => c.x === x && c.y === y);
      
      const getFoundColor = (x, y) => {
        const colors = ['#FFD93D', '#6BCB77', '#4D96FF', '#FF6B6B', '#C9B1FF', '#FF9F45', '#45FFC8'];
        
        // 정답 보기 모드일 때 모든 단어 위치 표시
        if (showAnswers) {
          for (let i = 0; i < placements.length; i++) {
            const p = placements[i];
            if (p.cells.some(c => c.x === x && c.y === y)) {
              return colors[i % colors.length];
            }
          }
          return null;
        }
        
        // 일반 모드: 찾은 단어만 표시
        for (let i = 0; i < placements.length; i++) {
          const p = placements[i];
          if (foundWords.includes(p.word) && p.cells.some(c => c.x === x && c.y === y))
            return colors[foundWords.indexOf(p.word) % colors.length];
        }
        return null;
      };

      const handleMatchingChange = (eng, meaning) => setMatchingAnswers(prev => ({ ...prev, [eng]: meaning }));

      const checkAnswers = () => {
        setIsTimerRunning(false);
        const words = puzzleData.words;
        let correct = 0;
        const wrong = [];
        const checked = {};
        words.forEach(w => {
          const key = w.english.toUpperCase();
          const ans = matchingAnswers[key];
          const isCorrect = ans === w.korean;
          checked[key] = isCorrect;
          if (isCorrect) correct++;
          else wrong.push({ english: w.english, userAnswer: ans || '(미선택)', correctAnswer: w.korean });
        });
        setCheckedAnswers(checked);
        const total = words.length * 2;
        const totalCorrect = foundWords.length + correct;
        setResultData({
          score: Math.round((totalCorrect / total) * 100),
          wordSearchCorrect: foundWords.length, wordSearchTotal: placements.length,
          matchingCorrect: correct, matchingTotal: words.length,
          wrongAnswers: wrong, time: timer, isPerfect: totalCorrect === total
        });
        setShowResult(true);
      };

      const retryWrong = () => {
        setShowResult(false);
        const newAns = {};
        puzzleData.words.forEach(w => { const key = w.english.toUpperCase(); if (checkedAnswers[key]) newAns[key] = matchingAnswers[key]; });
        setMatchingAnswers(newAns); setCheckedAnswers({}); setIsTimerRunning(true);
      };

      const resetGame = () => {
        if (!puzzleData) return;
        const { words, savedGrid, savedPlacements } = puzzleData;
        
        // 저장된 그리드 재사용 (동일한 배치 유지)
        if (savedGrid && savedPlacements) {
          setGrid(savedGrid); 
          setPlacements(savedPlacements);
        } else {
          // 이전 버전 호환: 저장된 그리드가 없으면 새로 생성
          const { gridSize, allowDiagonal, allowReverse } = puzzleData;
          const { grid: g, placements: p } = generateWordSearchGrid(words, gridSize, allowDiagonal, allowReverse);
          setGrid(g); setPlacements(p);
        }
        
        setFoundWords([]); setTimer(0);
        setIsTimerRunning(true); setMatchingAnswers({}); setCheckedAnswers({});
        setShowResult(false); setShuffledMeanings(shuffleArray(words.map(w => w.korean)));
      };

      const isAllComplete = () => puzzleData && foundWords.length === placements.length && puzzleData.words.every(w => matchingAnswers[w.english.toUpperCase()]);

      if (mode === 'home') {
        return (
          <div className="app-container">
            <div className="home-screen">
              <div className="logo-container">
                <div className="logo-icon">🔍</div>
                <h1 className="main-title">Edu-Puzzle Maker</h1>
                <p className="subtitle">재미있는 영어 단어 학습 퍼즐!</p>
              </div>
              <div className="home-buttons">
                <button className="home-btn create-btn" onClick={() => setMode('create')}>
                  <span className="btn-icon">✏️</span>
                  <span className="btn-text">퍼즐 만들기</span>
                  <span className="btn-desc">선생님용</span>
                </button>
              </div>
              <div className="home-features">
                <div className="feature"><span>🔤</span><span>단어 찾기 퍼즐</span></div>
                <div className="feature"><span>🔗</span><span>영어-한글 뜻 연결</span></div>
                <div className="feature"><span>✅</span><span>자동 채점</span></div>
              </div>
            </div>
          </div>
        );
      }

      if (mode === 'create') {
        return (
          <div className="app-container">
            <div className="create-screen">
              <button className="back-btn" onClick={() => setMode('home')}>← 홈으로</button>
              <h2 className="screen-title">🎯 퍼즐 만들기</h2>
              <div className="form-group">
                <label>퍼즐 제목</label>
                <input type="text" placeholder="예: 3단원 필수 영단어" value={title} onChange={(e) => setTitle(e.target.value)} className="text-input" />
              </div>
              <div className="form-group">
                <label>단어 입력 (최대 15개)</label>
                <div className="input-instructions">
                  <p>💡 <strong>입력 방법:</strong></p>
                  <p>• 영어 단어 입력 → <span className="key-hint">스페이스바</span> 또는 <span className="key-hint">Enter</span> → 한글 뜻 입력</p>
                  <p>• 한글 뜻 입력 후 <span className="key-hint">스페이스바</span> 또는 <span className="key-hint">Enter</span> → 다음 단어로 이동</p>
                </div>
                <div className="word-pairs-container">
                  {wordPairs.map((pair, index) => (
                    <div key={index} className="word-pair-row">
                      <span className="pair-number">{index + 1}</span>
                      <input
                        id={`english-${index}`}
                        type="text"
                        placeholder="영어 단어"
                        value={pair.english}
                        onChange={(e) => updateWordPair(index, 'english', e.target.value)}
                        onKeyDown={(e) => handleKeyDown(e, index, 'english')}
                        className="word-input english-input"
                      />
                      <span className="arrow-divider">→</span>
                      <input
                        id={`korean-${index}`}
                        type="text"
                        placeholder="한글 뜻"
                        value={pair.korean}
                        onChange={(e) => updateWordPair(index, 'korean', e.target.value)}
                        onKeyDown={(e) => handleKeyDown(e, index, 'korean')}
                        className="word-input korean-input"
                      />
                      <button 
                        className="remove-pair-btn"
                        onClick={() => removeWordPair(index)}
                        disabled={wordPairs.length === 1}
                        title="삭제"
                      >✕</button>
                    </div>
                  ))}
                </div>
                {wordPairs.length < 15 && (
                  <button className="add-pair-btn" onClick={addWordPair}>
                    + 단어 추가
                  </button>
                )}
                <p className="word-count">{wordPairs.filter(p => p.english.trim() && p.korean.trim()).length}/15개 입력됨</p>
              </div>
              <div className="form-group">
                <label>난이도</label>
                <div className="difficulty-selector">
                  <button className={`diff-btn ${difficulty === 'easy' ? 'active' : ''}`} onClick={() => setDifficulty('easy')}>
                    <span className="diff-icon">😊</span><span className="diff-name">쉬움</span><span className="diff-desc">10×10, 가로/세로</span>
                  </button>
                  <button className={`diff-btn ${difficulty === 'hard' ? 'active' : ''}`} onClick={() => setDifficulty('hard')}>
                    <span className="diff-icon">🔥</span><span className="diff-name">어려움</span><span className="diff-desc">15×15, 대각선+역방향</span>
                  </button>
                </div>
              </div>
              <button className="generate-btn" onClick={generatePuzzle}>✨ 퍼즐 생성하기</button>
              {puzzleCode && (
                <div className="url-result">
                  <h3>🎉 퍼즐이 생성되었습니다!</h3>
                  <div className="result-section">
                    <label>📎 학생 배포용 링크</label>
                    <div className="url-box">
                      <input type="text" value={generatedUrl} readOnly className="url-input" />
                      <button className="copy-btn" onClick={copyUrl}>복사</button>
                    </div>
                  </div>
                  <div className="action-buttons">
                    <button className="preview-btn" onClick={() => { setPuzzleData(decodeData(puzzleCode)); setMode('play'); setIsPreviewMode(true); setShowAnswers(false); }}>👀 미리보기</button>
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      }

      if (mode === 'play' && grid.length > 0) {
        const wordsToFind = placements.map(p => p.word);
        const gridSize = grid.length;
        const wsComplete = foundWords.length === placements.length;
        const matchComplete = puzzleData.words.every(w => matchingAnswers[w.english.toUpperCase()]);

        return (
          <div className="app-container">
            <Confetti active={resultData?.isPerfect} />
            {showResult && resultData && (
              <div className="result-modal">
                <div className="result-content">
                  <div className="result-icon">{resultData.isPerfect ? '🎉' : '📝'}</div>
                  <h2>{resultData.isPerfect ? '완벽해요!' : '채점 결과'}</h2>
                  <p className="result-score">점수: {resultData.score}점</p>
                  <div className="result-details">
                    <p>⏱️ 소요 시간: {formatTime(resultData.time)}</p>
                    <p>🔍 단어 찾기: {resultData.wordSearchCorrect} / {resultData.wordSearchTotal}</p>
                    <p>🔗 뜻 연결: {resultData.matchingCorrect} / {resultData.matchingTotal}</p>
                    {resultData.wrongAnswers.length > 0 && (
                      <div className="wrong-list">
                        <h4>❌ 틀린 문제</h4>
                        {resultData.wrongAnswers.map((item, i) => (
                          <div key={i} className="wrong-item">
                            <strong>{item.english}</strong><br/>
                            내 답: {item.userAnswer}<br/>
                            정답: <span style={{color: '#6BCB77'}}>{item.correctAnswer}</span>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <div className="result-buttons">
                    {!resultData.isPerfect && <button className="retry-btn" onClick={retryWrong}>🔄 다시 풀기</button>}
                    <button className="play-again-btn" onClick={resetGame}>🆕 새로 시작</button>
                    <button className="home-btn-small" onClick={() => { window.history.pushState({}, '', window.location.pathname); setMode('home'); setPuzzleData(null); setIsPreviewMode(false); setShowAnswers(false); }}>🏠 홈으로</button>
                  </div>
                </div>
              </div>
            )}
            <div className="play-screen">
              <div className="play-header">
                <h2 className="puzzle-title">{puzzleData?.title || '영어 단어 학습'}</h2>
                <div className="timer">⏱️ {formatTime(timer)}</div>
              </div>
              
              {isPreviewMode && (
                <div className="teacher-controls">
                  <span className="teacher-badge">👩‍🏫 교사 미리보기</span>
                  <div className="teacher-buttons">
                    <button className={`answer-toggle-btn ${showAnswers ? 'active' : ''}`} onClick={() => setShowAnswers(!showAnswers)}>
                      {showAnswers ? '🙈 정답 숨기기' : '👁️ 정답 보기'}
                    </button>
                    <button className="back-to-create-btn" onClick={() => { setMode('create'); setShowAnswers(false); }}>
                      ✏️ 제작으로 돌아가기
                    </button>
                  </div>
                </div>
              )}
              <div className="section-box" style={{marginTop: 0, marginBottom: '1rem'}}>
                <h3>🔍 단어 찾기 <span className={`status-badge ${wsComplete ? 'complete' : 'incomplete'}`}>{wsComplete ? '완료!' : `${foundWords.length}/${wordsToFind.length}`}</span></h3>
              </div>
              <div className="grid-wrapper">
                <div className={`grid-container ${wrongSelection ? 'shake' : ''} size-${gridSize}`} style={{ gridTemplateColumns: `repeat(${gridSize}, 1fr)` }} ref={gridRef} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchEnd={handleMouseUp}>
                  {grid.map((row, y) => row.map((cell, x) => {
                    const color = getFoundColor(x, y);
                    return (
                      <div key={`${x}-${y}`} className={`grid-cell ${isCellSelected(x, y) ? 'selected' : ''} ${color ? 'found' : ''}`} style={color ? { backgroundColor: color } : {}}
                        onMouseDown={() => handleCellMouseDown(x, y)} onMouseEnter={() => handleCellMouseEnter(x, y)}
                        onTouchStart={(e) => { e.preventDefault(); handleCellMouseDown(x, y); }}
                        onTouchMove={(e) => { e.preventDefault(); const el = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY); if (el?.dataset.x) handleCellMouseEnter(+el.dataset.x, +el.dataset.y); }}
                        data-x={x} data-y={y}>{cell}</div>
                    );
                  }))}
                </div>
              </div>
              <div className="section-box">
                <h3>찾아야 할 단어</h3>
                <div className="words">{wordsToFind.map((word, i) => (<span key={i} className={`word-item ${foundWords.includes(word) ? 'found' : ''}`}>{word}</span>))}</div>
              </div>
              <div className="section-box">
                <h3>🔗 뜻 연결하기 <span className={`status-badge ${matchComplete ? 'complete' : 'incomplete'}`}>{matchComplete ? '완료!' : `${Object.keys(matchingAnswers).length}/${puzzleData.words.length}`}</span></h3>
                {puzzleData.words.map((word, i) => {
                  const key = word.english.toUpperCase();
                  const checked = checkedAnswers.hasOwnProperty(key);
                  const correct = checkedAnswers[key];
                  return (
                    <div key={i} className={`matching-row ${checked ? (correct ? 'correct' : 'incorrect') : ''} ${showAnswers ? 'show-answer' : ''}`}>
                      <div className="english-word">{word.english}</div>
                      <span className="arrow-icon">→</span>
                      <select className={`meaning-select ${checked ? (correct ? 'correct' : 'incorrect') : ''}`} value={matchingAnswers[key] || ''} onChange={(e) => handleMatchingChange(key, e.target.value)} disabled={checked && correct}>
                        <option value="">뜻을 선택하세요</option>
                        {shuffledMeanings.map((m, j) => <option key={j} value={m}>{m}</option>)}
                      </select>
                      {checked && !correct && <div className="correct-answer">정답: {word.korean}</div>}
                      {showAnswers && !checked && <div className="correct-answer">💡 정답: {word.korean}</div>}
                    </div>
                  );
                })}
              </div>
              <div className="submit-section">
                {!isAllComplete() && <p className="incomplete-warning">⚠️ 모든 활동을 완료해주세요!</p>}
                <button className="submit-btn" onClick={checkAnswers} disabled={!isAllComplete()}>✅ 활동 종료 & 채점하기</button>
              </div>
              <button className="reset-btn" onClick={resetGame}>🔄 처음부터 다시 시작</button>
            </div>
          </div>
        );
      }
      return <div className="app-container"><div className="loading">로딩 중...</div></div>;
    }
    ReactDOM.createRoot(document.getElementById('root')).render(<EduPuzzleMaker />);
  </script>
</body>
</html>
