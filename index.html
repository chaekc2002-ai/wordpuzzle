<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Edu-Puzzle Maker - ë‹¨ì–´ ì°¾ê¸° í¼ì¦</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Jua&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Noto Sans KR', sans-serif; }
    .app-container {
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      position: relative;
      overflow-x: hidden;
    }
    .app-container::before {
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-image: 
        radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255,255,255,0.15) 0%, transparent 50%);
      pointer-events: none;
    }
    .home-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      position: relative;
      z-index: 1;
    }
    .logo-container { text-align: center; margin-bottom: 3rem; }
    .logo-icon { font-size: 5rem; margin-bottom: 1rem; animation: bounce 2s ease-in-out infinite; }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }
    .main-title {
      font-family: 'Jua', sans-serif;
      font-size: 3.5rem;
      color: #fff;
      text-shadow: 4px 4px 0 rgba(0,0,0,0.2);
      margin-bottom: 0.5rem;
    }
    .subtitle { font-size: 1.3rem; color: rgba(255,255,255,0.9); }
    .home-buttons { display: flex; gap: 2rem; margin-bottom: 3rem; }
    .home-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 3rem;
      border: none;
      border-radius: 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    .create-btn { background: linear-gradient(135deg, #FFD93D 0%, #FF6B6B 100%); }
    .home-btn:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 15px 40px rgba(0,0,0,0.3); }
    .btn-icon { font-size: 3rem; margin-bottom: 0.5rem; }
    .btn-text { font-family: 'Jua', sans-serif; font-size: 1.5rem; color: #333; }
    .btn-desc { font-size: 0.9rem; color: rgba(0,0,0,0.6); margin-top: 0.3rem; }
    .home-features { display: flex; gap: 2rem; flex-wrap: wrap; justify-content: center; }
    .feature {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(255,255,255,0.2);
      backdrop-filter: blur(10px);
      padding: 1rem 1.5rem;
      border-radius: 50px;
      color: #fff;
      font-size: 1rem;
    }
    .create-screen {
      min-height: 100vh;
      padding: 2rem;
      max-width: 700px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    .back-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: #fff;
      padding: 0.8rem 1.5rem;
      border-radius: 50px;
      cursor: pointer;
      font-size: 1rem;
      margin-bottom: 2rem;
      transition: all 0.3s ease;
    }
    .back-btn:hover { background: rgba(255,255,255,0.3); }
    .screen-title {
      font-family: 'Jua', sans-serif;
      font-size: 2.5rem;
      color: #fff;
      text-align: center;
      margin-bottom: 2rem;
      text-shadow: 3px 3px 0 rgba(0,0,0,0.2);
    }
    .form-group { margin-bottom: 1.5rem; }
    .form-group label {
      display: block;
      color: #fff;
      font-weight: 700;
      margin-bottom: 0.5rem;
      font-size: 1.1rem;
    }
    .text-input, .words-input {
      width: 100%;
      padding: 1rem 1.5rem;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 16px;
      font-size: 1.1rem;
      background: rgba(255,255,255,0.95);
      font-family: 'Noto Sans KR', sans-serif;
      transition: all 0.3s ease;
    }
    .text-input:focus, .words-input:focus {
      outline: none;
      border-color: #FFD93D;
      box-shadow: 0 0 20px rgba(255,217,61,0.4);
    }
    .words-input { resize: vertical; min-height: 200px; }
    .input-instructions {
      background: rgba(255,255,255,0.15);
      padding: 1rem;
      border-radius: 12px;
      margin-bottom: 1rem;
      color: #fff;
    }
    .input-instructions p {
      margin-bottom: 0.3rem;
      font-size: 0.95rem;
    }
    .key-hint {
      background: rgba(255,255,255,0.3);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.85rem;
    }
    .word-pairs-container {
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      padding: 1rem;
      margin-bottom: 1rem;
      max-height: 400px;
      overflow-y: auto;
    }
    .word-pair-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.8rem;
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 10px;
      transition: all 0.2s ease;
    }
    .word-pair-row:hover {
      background: #f0f0f0;
    }
    .word-pair-row:last-child {
      margin-bottom: 0;
    }
    .pair-number {
      font-family: 'Jua', sans-serif;
      font-size: 1rem;
      color: #667eea;
      min-width: 24px;
      text-align: center;
    }
    .word-input {
      flex: 1;
      padding: 0.7rem 1rem;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
      font-family: 'Noto Sans KR', sans-serif;
      transition: all 0.2s ease;
    }
    .word-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102,126,234,0.2);
    }
    .english-input {
      background: #fff;
    }
    .korean-input {
      background: #fffbeb;
    }
    .arrow-divider {
      color: #667eea;
      font-size: 1.2rem;
      font-weight: bold;
    }
    .remove-pair-btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 50%;
      background: #ff6b6b;
      color: #fff;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .remove-pair-btn:hover:not(:disabled) {
      background: #ee5a5a;
      transform: scale(1.1);
    }
    .remove-pair-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .add-pair-btn {
      width: 100%;
      padding: 0.8rem;
      border: 2px dashed #667eea;
      border-radius: 10px;
      background: rgba(102,126,234,0.1);
      color: #667eea;
      font-family: 'Jua', sans-serif;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .add-pair-btn:hover {
      background: rgba(102,126,234,0.2);
      border-style: solid;
    }
    .word-count {
      text-align: right;
      color: rgba(255,255,255,0.8);
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }
    .input-hint { color: rgba(255,255,255,0.8); font-size: 0.9rem; margin-top: 0.5rem; }
    .difficulty-selector { display: flex; gap: 1rem; }
    .diff-btn {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 16px;
      background: rgba(255,255,255,0.1);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .diff-btn.active { background: rgba(255,255,255,0.95); border-color: #FFD93D; }
    .diff-icon { font-size: 2.5rem; margin-bottom: 0.5rem; }
    .diff-name { font-family: 'Jua', sans-serif; font-size: 1.3rem; color: #333; }
    .diff-desc { font-size: 0.85rem; color: #666; margin-top: 0.3rem; }
    .diff-btn:not(.active) .diff-name, .diff-btn:not(.active) .diff-desc { color: rgba(255,255,255,0.9); }
    .generate-btn {
      width: 100%;
      padding: 1.2rem;
      border: none;
      border-radius: 16px;
      background: linear-gradient(135deg, #FFD93D 0%, #FF6B6B 100%);
      color: #333;
      font-family: 'Jua', sans-serif;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    }
    .generate-btn:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
    .url-result {
      margin-top: 2rem;
      background: rgba(255,255,255,0.95);
      border-radius: 20px;
      padding: 2rem;
      text-align: center;
    }
    .url-result h3 {
      font-family: 'Jua', sans-serif;
      font-size: 1.5rem;
      color: #333;
      margin-bottom: 1.5rem;
    }
    .result-section {
      text-align: left;
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid #eee;
    }
    .result-section label {
      display: block;
      font-weight: 700;
      color: #333;
      margin-bottom: 0.5rem;
    }
    .url-box { display: flex; gap: 0.5rem; }
    .url-input {
      flex: 1;
      padding: 0.8rem;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 0.9rem;
    }
    .copy-btn {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 10px;
      background: #667eea;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .copy-btn:hover { background: #5a6fd6; }
    .action-buttons { display: flex; gap: 1rem; justify-content: center; margin-top: 1rem; }
    .preview-btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      background: linear-gradient(135deg, #6BCB77 0%, #4D96FF 100%);
      color: #fff;
      font-family: 'Jua', sans-serif;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .preview-btn:hover { transform: translateY(-2px); }
    .play-screen {
      min-height: 100vh;
      padding: 1.5rem;
      padding-bottom: 100px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      z-index: 1;
    }
    .play-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 550px;
      margin-bottom: 1rem;
    }
    .puzzle-title {
      font-family: 'Jua', sans-serif;
      font-size: 1.8rem;
      color: #fff;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
    }
    .timer {
      background: rgba(255,255,255,0.95);
      padding: 0.6rem 1.2rem;
      border-radius: 50px;
      font-family: 'Jua', sans-serif;
      font-size: 1.3rem;
      color: #333;
    }
    .grid-wrapper { width: 100%; display: flex; justify-content: center; padding: 0 1rem; }
    .grid-container {
      display: grid;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 10px;
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      user-select: none;
      touch-action: none;
      gap: 3px;
      aspect-ratio: 1;
    }
    .grid-container.size-10 { width: min(90vw, 450px); }
    .grid-container.size-15 { width: min(95vw, 550px); gap: 2px; padding: 8px; }
    .grid-container.shake { animation: shake 0.3s ease; }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    .grid-cell {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.95);
      border-radius: 4px;
      font-family: 'Jua', sans-serif;
      font-weight: 700;
      color: #333;
      cursor: pointer;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .grid-container.size-10 .grid-cell { font-size: clamp(1rem, 4vw, 1.5rem); }
    .grid-container.size-15 .grid-cell { font-size: clamp(0.7rem, 2.2vw, 1rem); border-radius: 3px; }
    .grid-cell:hover { background: rgba(255,255,255,1); transform: scale(1.02); }
    .grid-cell.selected {
      background: linear-gradient(135deg, #4D96FF 0%, #3a7bd5 100%);
      color: #fff;
      transform: scale(1.08);
      box-shadow: 0 4px 12px rgba(77,150,255,0.5);
      z-index: 1;
    }
    .grid-cell.found { color: #fff; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    .section-box {
      margin-top: 1.5rem;
      background: rgba(255,255,255,0.95);
      padding: 1.5rem;
      border-radius: 20px;
      width: 100%;
      max-width: 550px;
    }
    .section-box h3 {
      font-family: 'Jua', sans-serif;
      font-size: 1.3rem;
      color: #333;
      margin-bottom: 1rem;
      text-align: center;
    }
    .words {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      justify-content: center;
    }
    .word-item {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      padding: 0.5rem 1rem;
      border-radius: 50px;
      font-family: 'Jua', sans-serif;
      font-size: 1.1rem;
      transition: all 0.3s ease;
    }
    .word-item.found { background: #6BCB77; text-decoration: line-through; opacity: 0.7; }
    .matching-row {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
      padding: 0.8rem;
      background: #f8f9fa;
      border-radius: 12px;
      transition: all 0.3s ease;
    }
    .matching-row.correct { background: #d4edda; border: 2px solid #6BCB77; }
    .matching-row.incorrect { background: #f8d7da; border: 2px solid #FF6B6B; }
    .english-word {
      flex: 1;
      font-family: 'Jua', sans-serif;
      font-size: 1.2rem;
      padding: 0.5rem 1rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-radius: 10px;
      text-align: center;
    }
    .arrow-icon { font-size: 1.5rem; color: #666; }
    .meaning-select {
      flex: 1.5;
      padding: 0.8rem 1rem;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 1rem;
      font-family: 'Noto Sans KR', sans-serif;
      background: #fff;
      cursor: pointer;
    }
    .meaning-select:focus { outline: none; border-color: #667eea; }
    .meaning-select.correct { border-color: #6BCB77; background: #d4edda; }
    .meaning-select.incorrect { border-color: #FF6B6B; background: #f8d7da; }
    .correct-answer { font-size: 0.85rem; color: #6BCB77; margin-top: 0.3rem; font-weight: 700; width: 100%; }
    .submit-section {
      margin-top: 2rem;
      width: 100%;
      max-width: 550px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    .submit-btn {
      width: 100%;
      padding: 1.2rem;
      border: none;
      border-radius: 16px;
      background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%);
      color: #333;
      font-family: 'Jua', sans-serif;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    }
    .submit-btn:hover { transform: translateY(-3px); }
    .submit-btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
    .incomplete-warning {
      color: #FFD93D;
      font-weight: 700;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .result-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
      padding: 1rem;
    }
    .result-content {
      background: #fff;
      padding: 2rem;
      border-radius: 30px;
      text-align: center;
      animation: popIn 0.5s ease;
      max-width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      width: 400px;
    }
    .result-icon { font-size: 5rem; margin-bottom: 1rem; }
    .result-content h2 { font-family: 'Jua', sans-serif; font-size: 2rem; color: #333; }
    .result-score { font-family: 'Jua', sans-serif; font-size: 1.5rem; color: #667eea; margin: 1rem 0; }
    .result-details {
      text-align: left;
      background: #f8f9fa;
      padding: 1rem;
      border-radius: 12px;
      margin: 1rem 0;
    }
    .result-details p { margin-bottom: 0.5rem; }
    .wrong-list { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ddd; }
    .wrong-list h4 { color: #FF6B6B; margin-bottom: 0.5rem; }
    .wrong-item {
      background: #fff;
      padding: 0.5rem;
      border-radius: 8px;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      border-left: 3px solid #FF6B6B;
    }
    .result-buttons { display: flex; gap: 1rem; justify-content: center; margin-top: 1.5rem; flex-wrap: wrap; }
    .retry-btn, .play-again-btn, .home-btn-small {
      padding: 1rem 2rem;
      border: none;
      border-radius: 50px;
      font-family: 'Jua', sans-serif;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .retry-btn { background: linear-gradient(135deg, #FF6B6B 0%, #FFD93D 100%); color: #333; }
    .play-again-btn { background: linear-gradient(135deg, #6BCB77 0%, #4D96FF 100%); color: #fff; }
    .home-btn-small { background: linear-gradient(135deg, #764ba2 0%, #667eea 100%); color: #fff; }
    .retry-btn:hover, .play-again-btn:hover, .home-btn-small:hover { transform: translateY(-3px); }
    .reset-btn {
      margin-top: 1.5rem;
      padding: 1rem 2rem;
      border: none;
      border-radius: 50px;
      background: rgba(255,255,255,0.2);
      color: #fff;
      font-family: 'Jua', sans-serif;
      font-size: 1.1rem;
      cursor: pointer;
    }
    .reset-btn:hover { background: rgba(255,255,255,0.3); }
    .status-badge {
      display: inline-block;
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 700;
      margin-left: 0.5rem;
    }
    .status-badge.complete { background: #6BCB77; color: #fff; }
    .status-badge.incomplete { background: #FFD93D; color: #333; }
    .teacher-controls {
      width: 100%;
      max-width: 550px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255,255,255,0.95);
      padding: 0.8rem 1.2rem;
      border-radius: 12px;
      margin-bottom: 1rem;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    .teacher-badge {
      font-family: 'Jua', sans-serif;
      font-size: 1rem;
      color: #667eea;
      background: #f0f0ff;
      padding: 0.4rem 0.8rem;
      border-radius: 20px;
    }
    .answer-toggle-btn {
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      font-family: 'Jua', sans-serif;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .answer-toggle-btn:hover {
      transform: scale(1.05);
    }
    .answer-toggle-btn.active {
      background: linear-gradient(135deg, #6BCB77 0%, #4D96FF 100%);
    }
    .matching-row.show-answer {
      background: #f0f8ff;
      border: 2px dashed #667eea;
    }
    .confetti-container {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 999;
      overflow: hidden;
    }
    .confetti-piece {
      position: absolute;
      width: 10px; height: 10px;
      top: -20px;
      animation: confettiFall linear forwards;
    }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes popIn {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    .loading {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 1.5rem;
    }
    @media (max-width: 600px) {
      .main-title { font-size: 2.5rem; }
      .home-buttons { flex-direction: column; }
      .home-btn { padding: 1.5rem 2rem; }
      .home-features { flex-direction: column; align-items: center; }
      .difficulty-selector { flex-direction: column; }
      .grid-container { padding: 6px; gap: 2px; }
      .grid-container.size-10 .grid-cell { font-size: clamp(0.9rem, 3.5vw, 1.3rem); }
      .grid-container.size-15 .grid-cell { font-size: clamp(0.6rem, 2vw, 0.85rem); }
      .play-header { flex-direction: column; gap: 0.5rem; text-align: center; }
      .puzzle-title { font-size: 1.5rem; }
      .result-content { padding: 1.5rem; }
      .result-buttons { flex-direction: column; }
      .matching-row { flex-direction: column; gap: 0.5rem; }
      .english-word, .meaning-select { width: 100%; flex: none; }
      .arrow-icon { transform: rotate(90deg); }
      .teacher-controls { flex-direction: column; gap: 0.5rem; text-align: center; }
      .word-pair-row { flex-wrap: wrap; }
      .word-input { min-width: 100px; }
      .arrow-divider { display: none; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const encodeData = (data) => {
      try {
        const jsonStr = JSON.stringify(data);
        const utf8Bytes = new TextEncoder().encode(jsonStr);
        const binaryStr = Array.from(utf8Bytes).map(byte => String.fromCharCode(byte)).join('');
        const base64 = btoa(binaryStr);
        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
      } catch (e) { return null; }
    };

    const decodeData = (encoded) => {
      try {
        let base64 = encoded.replace(/-/g, '+').replace(/_/g, '/');
        while (base64.length % 4) base64 += '=';
        const binaryStr = atob(base64);
        const utf8Bytes = new Uint8Array(binaryStr.split('').map(char => char.charCodeAt(0)));
        return JSON.parse(new TextDecoder().decode(utf8Bytes));
      } catch (e) { return null; }
    };

    const shuffleArray = (arr) => {
      const s = [...arr];
      for (let i = s.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [s[i], s[j]] = [s[j], s[i]];
      }
      return s;
    };

    const generateWordSearchGrid = (words, gridSize, allowDiagonal, allowReverse) => {
      const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(''));
      const placements = [];
      const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }];
      if (allowDiagonal) directions.push({ dx: 1, dy: 1 }, { dx: 1, dy: -1 });

      const canPlace = (word, sx, sy, dx, dy) => {
        for (let i = 0; i < word.length; i++) {
          const x = sx + i * dx, y = sy + i * dy;
          if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return false;
          if (grid[y][x] !== '' && grid[y][x] !== word[i]) return false;
        }
        return true;
      };

      const placeWord = (word, sx, sy, dx, dy) => {
        const cells = [];
        for (let i = 0; i < word.length; i++) {
          const x = sx + i * dx, y = sy + i * dy;
          grid[y][x] = word[i];
          cells.push({ x, y });
        }
        return cells;
      };

      const englishWords = words.map(w => w.english.toUpperCase());
      [...englishWords].sort((a, b) => b.length - a.length).forEach(word => {
        let placed = false, attempts = 0;
        while (!placed && attempts < 100) {
          const shouldReverse = allowReverse && Math.random() > 0.5;
          const w = shouldReverse ? word.split('').reverse().join('') : word;
          const dir = directions[Math.floor(Math.random() * directions.length)];
          const sx = Math.floor(Math.random() * gridSize);
          const sy = Math.floor(Math.random() * gridSize);
          if (canPlace(w, sx, sy, dir.dx, dir.dy)) {
            placements.push({ word, cells: placeWord(w, sx, sy, dir.dx, dir.dy), reversed: shouldReverse });
            placed = true;
          }
          attempts++;
        }
      });

      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let y = 0; y < gridSize; y++)
        for (let x = 0; x < gridSize; x++)
          if (grid[y][x] === '') grid[y][x] = chars[Math.floor(Math.random() * 26)];

      return { grid, placements };
    };

    const Confetti = ({ active }) => {
      if (!active) return null;
      const pieces = Array(50).fill(null).map((_, i) => ({
        id: i, left: Math.random() * 100, delay: Math.random() * 2, duration: 2 + Math.random() * 2,
        color: ['#FFD93D', '#6BCB77', '#4D96FF', '#FF6B6B', '#C9B1FF'][Math.floor(Math.random() * 5)]
      }));
      return (
        <div className="confetti-container">
          {pieces.map(p => (
            <div key={p.id} className="confetti-piece" style={{
              left: `${p.left}%`, animationDelay: `${p.delay}s`,
              animationDuration: `${p.duration}s`, backgroundColor: p.color
            }} />
          ))}
        </div>
      );
    };

    function EduPuzzleMaker() {
      const [mode, setMode] = useState('home');
      const [puzzleData, setPuzzleData] = useState(null);
      const [title, setTitle] = useState('');
      const [wordsInput, setWordsInput] = useState('');
      const [difficulty, setDifficulty] = useState('easy');
      const [generatedUrl, setGeneratedUrl] = useState('');
      const [baseUrl, setBaseUrl] = useState('');
      const [puzzleCode, setPuzzleCode] = useState('');
      const [wordPairs, setWordPairs] = useState([{ english: '', korean: '' }]);
      const [grid, setGrid] = useState([]);
      const [placements, setPlacements] = useState([]);
      const [foundWords, setFoundWords] = useState([]);
      const [selecting, setSelecting] = useState(false);
      const [selectedCells, setSelectedCells] = useState([]);
      const [startCell, setStartCell] = useState(null);
      const [timer, setTimer] = useState(0);
      const [isTimerRunning, setIsTimerRunning] = useState(false);
      const [wrongSelection, setWrongSelection] = useState(false);
      const [matchingAnswers, setMatchingAnswers] = useState({});
      const [shuffledMeanings, setShuffledMeanings] = useState([]);
      const [showResult, setShowResult] = useState(false);
      const [resultData, setResultData] = useState(null);
      const [checkedAnswers, setCheckedAnswers] = useState({});
      const [isPreviewMode, setIsPreviewMode] = useState(false);
      const [showAnswers, setShowAnswers] = useState(false);
      const gridRef = useRef(null);

      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const data = params.get('puzzle');
        if (data) {
          const decoded = decodeData(data);
          if (decoded) { setPuzzleData(decoded); setMode('play'); setIsPreviewMode(false); }
        }
        setBaseUrl(window.location.origin + window.location.pathname);
      }, []);

      useEffect(() => {
        if (puzzleData && mode === 'play') {
          const { words, gridSize, allowDiagonal, allowReverse, savedGrid, savedPlacements } = puzzleData;
          
          // ì €ì¥ëœ ê·¸ë¦¬ë“œê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„± (ì´ì „ ë²„ì „ í˜¸í™˜)
          let g, p;
          if (savedGrid && savedPlacements) {
            g = savedGrid;
            p = savedPlacements;
          } else {
            const result = generateWordSearchGrid(words, gridSize, allowDiagonal, allowReverse);
            g = result.grid;
            p = result.placements;
          }
          
          setGrid(g); setPlacements(p); setFoundWords([]); setTimer(0);
          setIsTimerRunning(true); setMatchingAnswers({}); setCheckedAnswers({});
          setShowResult(false); setShuffledMeanings(shuffleArray(words.map(w => w.korean)));
        }
      }, [puzzleData, mode]);

      useEffect(() => {
        let interval;
        if (isTimerRunning) interval = setInterval(() => setTimer(t => t + 1), 1000);
        return () => clearInterval(interval);
      }, [isTimerRunning]);

      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

      const generatePuzzle = () => {
        const words = wordPairs
          .filter(pair => pair.english.trim() && pair.korean.trim())
          .filter(pair => /^[a-zA-Z]+$/.test(pair.english.trim()))
          .map(pair => ({ english: pair.english.trim(), korean: pair.korean.trim() }))
          .slice(0, 15);
        
        if (words.length === 0) { alert('ìœ íš¨í•œ ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!\nì˜ì–´ ë‹¨ì–´ëŠ” ì•ŒíŒŒë²³ë§Œ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.'); return; }
        const gridSize = difficulty === 'easy' ? 10 : 15;
        const allowDiagonal = difficulty === 'hard';
        const allowReverse = difficulty === 'hard';
        
        const { grid: generatedGrid, placements: generatedPlacements } = generateWordSearchGrid(words, gridSize, allowDiagonal, allowReverse);
        
        const data = { 
          title: title || 'ì˜ì–´ ë‹¨ì–´ í•™ìŠµ', 
          words, 
          gridSize, 
          allowDiagonal, 
          allowReverse,
          savedGrid: generatedGrid,
          savedPlacements: generatedPlacements
        };
        const encoded = encodeData(data);
        setPuzzleCode(encoded);
        if (baseUrl) setGeneratedUrl(`${baseUrl.replace(/\/$/, '')}?puzzle=${encoded}`);
      };
      
      const updateWordPair = (index, field, value) => {
        const newPairs = [...wordPairs];
        newPairs[index][field] = value;
        setWordPairs(newPairs);
      };
      
      const addWordPair = () => {
        if (wordPairs.length < 15) {
          setWordPairs([...wordPairs, { english: '', korean: '' }]);
        }
      };
      
      const removeWordPair = (index) => {
        if (wordPairs.length > 1) {
          const newPairs = wordPairs.filter((_, i) => i !== index);
          setWordPairs(newPairs);
        }
      };
      
      const handleKeyDown = (e, index, field) => {
        if (e.key === ' ' && field === 'english') {
          e.preventDefault();
          const koreanInput = document.getElementById(`korean-${index}`);
          if (koreanInput) koreanInput.focus();
        } else if (e.key === ' ' && field === 'korean' && e.target.value.trim()) {
          e.preventDefault();
          if (index === wordPairs.length - 1 && wordPairs.length < 15) {
            addWordPair();
            setTimeout(() => {
              const nextEnglish = document.getElementById(`english-${index + 1}`);
              if (nextEnglish) nextEnglish.focus();
            }, 50);
          } else if (index < wordPairs.length - 1) {
            const nextEnglish = document.getElementById(`english-${index + 1}`);
            if (nextEnglish) nextEnglish.focus();
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (field === 'english') {
            const koreanInput = document.getElementById(`korean-${index}`);
            if (koreanInput) koreanInput.focus();
          } else if (field === 'korean') {
            if (index === wordPairs.length - 1 && wordPairs.length < 15) {
              addWordPair();
              setTimeout(() => {
                const nextEnglish = document.getElementById(`english-${index + 1}`);
                if (nextEnglish) nextEnglish.focus();
              }, 50);
            } else if (index < wordPairs.length - 1) {
              const nextEnglish = document.getElementById(`english-${index + 1}`);
              if (nextEnglish) nextEnglish.focus();
            }
          }
        }
      };

      const copyUrl = () => { navigator.clipboard.writeText(generatedUrl); alert('ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!'); };

      const getCellsInLine = (start, end) => {
        if (!start || !end) return [];
        const dx = Math.sign(end.x - start.x), dy = Math.sign(end.y - start.y);
        if (dx !== 0 && dy !== 0 && Math.abs(end.x - start.x) !== Math.abs(end.y - start.y)) return [start];
        const cells = [];
        let x = start.x, y = start.y;
        while (true) { cells.push({ x, y }); if (x === end.x && y === end.y) break; x += dx; y += dy; if (cells.length > 20) break; }
        return cells;
      };

      const handleCellMouseDown = (x, y) => { setSelecting(true); setStartCell({ x, y }); setSelectedCells([{ x, y }]); setWrongSelection(false); };
      const handleCellMouseEnter = (x, y) => { if (selecting && startCell) setSelectedCells(getCellsInLine(startCell, { x, y })); };
      const handleMouseUp = () => {
        if (selecting && selectedCells.length > 1) {
          const word = selectedCells.map(c => grid[c.y][c.x]).join('');
          const rev = word.split('').reverse().join('');
          const match = placements.find(p => (word === p.word || rev === p.word) && !foundWords.includes(p.word));
          if (match) setFoundWords([...foundWords, match.word]);
          else { setWrongSelection(true); setTimeout(() => setWrongSelection(false), 300); }
        }
        setSelecting(false); setSelectedCells([]); setStartCell(null);
      };

      const isCellSelected = (x, y) => selectedCells.some(c => c.x === x && c.y === y);
      
      const getFoundColor = (x, y) => {
        const colors = ['#FFD93D', '#6BCB77', '#4D96FF', '#FF6B6B', '#C9B1FF', '#FF9F45', '#45FFC8'];
        
        // ì •ë‹µ ë³´ê¸° ëª¨ë“œì¼ ë•Œ ëª¨ë“  ë‹¨ì–´ ìœ„ì¹˜ í‘œì‹œ
        if (showAnswers) {
          for (let i = 0; i < placements.length; i++) {
            const p = placements[i];
            if (p.cells.some(c => c.x === x && c.y === y)) {
              return colors[i % colors.length];
            }
          }
          return null;
        }
        
        // ì¼ë°˜ ëª¨ë“œ: ì°¾ì€ ë‹¨ì–´ë§Œ í‘œì‹œ
        for (let i = 0; i < placements.length; i++) {
          const p = placements[i];
          if (foundWords.includes(p.word) && p.cells.some(c => c.x === x && c.y === y))
            return colors[foundWords.indexOf(p.word) % colors.length];
        }
        return null;
      };

      const handleMatchingChange = (eng, meaning) => setMatchingAnswers(prev => ({ ...prev, [eng]: meaning }));

      const checkAnswers = () => {
        setIsTimerRunning(false);
        const words = puzzleData.words;
        let correct = 0;
        const wrong = [];
        const checked = {};
        words.forEach(w => {
          const key = w.english.toUpperCase();
          const ans = matchingAnswers[key];
          const isCorrect = ans === w.korean;
          checked[key] = isCorrect;
          if (isCorrect) correct++;
          else wrong.push({ english: w.english, userAnswer: ans || '(ë¯¸ì„ íƒ)', correctAnswer: w.korean });
        });
        setCheckedAnswers(checked);
        const total = words.length * 2;
        const totalCorrect = foundWords.length + correct;
        setResultData({
          score: Math.round((totalCorrect / total) * 100),
          wordSearchCorrect: foundWords.length, wordSearchTotal: placements.length,
          matchingCorrect: correct, matchingTotal: words.length,
          wrongAnswers: wrong, time: timer, isPerfect: totalCorrect === total
        });
        setShowResult(true);
      };

      const retryWrong = () => {
        setShowResult(false);
        const newAns = {};
        puzzleData.words.forEach(w => { const key = w.english.toUpperCase(); if (checkedAnswers[key]) newAns[key] = matchingAnswers[key]; });
        setMatchingAnswers(newAns); setCheckedAnswers({}); setIsTimerRunning(true);
      };

      const resetGame = () => {
        if (!puzzleData) return;
        const { words, savedGrid, savedPlacements } = puzzleData;
        
        // ì €ì¥ëœ ê·¸ë¦¬ë“œ ì¬ì‚¬ìš© (ë™ì¼í•œ ë°°ì¹˜ ìœ ì§€)
        if (savedGrid && savedPlacements) {
          setGrid(savedGrid); 
          setPlacements(savedPlacements);
        } else {
          // ì´ì „ ë²„ì „ í˜¸í™˜: ì €ì¥ëœ ê·¸ë¦¬ë“œê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
          const { gridSize, allowDiagonal, allowReverse } = puzzleData;
          const { grid: g, placements: p } = generateWordSearchGrid(words, gridSize, allowDiagonal, allowReverse);
          setGrid(g); setPlacements(p);
        }
        
        setFoundWords([]); setTimer(0);
        setIsTimerRunning(true); setMatchingAnswers({}); setCheckedAnswers({});
        setShowResult(false); setShuffledMeanings(shuffleArray(words.map(w => w.korean)));
      };

      const isAllComplete = () => puzzleData && foundWords.length === placements.length && puzzleData.words.every(w => matchingAnswers[w.english.toUpperCase()]);

      if (mode === 'home') {
        return (
          <div className="app-container">
            <div className="home-screen">
              <div className="logo-container">
                <div className="logo-icon">ğŸ”</div>
                <h1 className="main-title">Edu-Puzzle Maker</h1>
                <p className="subtitle">ì¬ë¯¸ìˆëŠ” ì˜ì–´ ë‹¨ì–´ í•™ìŠµ í¼ì¦!</p>
              </div>
              <div className="home-buttons">
                <button className="home-btn create-btn" onClick={() => setMode('create')}>
                  <span className="btn-icon">âœï¸</span>
                  <span className="btn-text">í¼ì¦ ë§Œë“¤ê¸°</span>
                  <span className="btn-desc">ì„ ìƒë‹˜ìš©</span>
                </button>
              </div>
              <div className="home-features">
                <div className="feature"><span>ğŸ”¤</span><span>ë‹¨ì–´ ì°¾ê¸° í¼ì¦</span></div>
                <div className="feature"><span>ğŸ”—</span><span>ì˜ì–´-í•œê¸€ ëœ» ì—°ê²°</span></div>
                <div className="feature"><span>âœ…</span><span>ìë™ ì±„ì </span></div>
              </div>
            </div>
          </div>
        );
      }

      if (mode === 'create') {
        return (
          <div className="app-container">
            <div className="create-screen">
              <button className="back-btn" onClick={() => setMode('home')}>â† í™ˆìœ¼ë¡œ</button>
              <h2 className="screen-title">ğŸ¯ í¼ì¦ ë§Œë“¤ê¸°</h2>
              <div className="form-group">
                <label>í¼ì¦ ì œëª©</label>
                <input type="text" placeholder="ì˜ˆ: 3ë‹¨ì› í•„ìˆ˜ ì˜ë‹¨ì–´" value={title} onChange={(e) => setTitle(e.target.value)} className="text-input" />
              </div>
              <div className="form-group">
                <label>ë‹¨ì–´ ì…ë ¥ (ìµœëŒ€ 15ê°œ)</label>
                <div className="input-instructions">
                  <p>ğŸ’¡ <strong>ì…ë ¥ ë°©ë²•:</strong></p>
                  <p>â€¢ ì˜ì–´ ë‹¨ì–´ ì…ë ¥ â†’ <span className="key-hint">ìŠ¤í˜ì´ìŠ¤ë°”</span> ë˜ëŠ” <span className="key-hint">Enter</span> â†’ í•œê¸€ ëœ» ì…ë ¥</p>
                  <p>â€¢ í•œê¸€ ëœ» ì…ë ¥ í›„ <span className="key-hint">ìŠ¤í˜ì´ìŠ¤ë°”</span> ë˜ëŠ” <span className="key-hint">Enter</span> â†’ ë‹¤ìŒ ë‹¨ì–´ë¡œ ì´ë™</p>
                </div>
                <div className="word-pairs-container">
                  {wordPairs.map((pair, index) => (
                    <div key={index} className="word-pair-row">
                      <span className="pair-number">{index + 1}</span>
                      <input
                        id={`english-${index}`}
                        type="text"
                        placeholder="ì˜ì–´ ë‹¨ì–´"
                        value={pair.english}
                        onChange={(e) => updateWordPair(index, 'english', e.target.value)}
                        onKeyDown={(e) => handleKeyDown(e, index, 'english')}
                        className="word-input english-input"
                      />
                      <span className="arrow-divider">â†’</span>
                      <input
                        id={`korean-${index}`}
                        type="text"
                        placeholder="í•œê¸€ ëœ»"
                        value={pair.korean}
                        onChange={(e) => updateWordPair(index, 'korean', e.target.value)}
                        onKeyDown={(e) => handleKeyDown(e, index, 'korean')}
                        className="word-input korean-input"
                      />
                      <button 
                        className="remove-pair-btn"
                        onClick={() => removeWordPair(index)}
                        disabled={wordPairs.length === 1}
                        title="ì‚­ì œ"
                      >âœ•</button>
                    </div>
                  ))}
                </div>
                {wordPairs.length < 15 && (
                  <button className="add-pair-btn" onClick={addWordPair}>
                    + ë‹¨ì–´ ì¶”ê°€
                  </button>
                )}
                <p className="word-count">{wordPairs.filter(p => p.english.trim() && p.korean.trim()).length}/15ê°œ ì…ë ¥ë¨</p>
              </div>
              <div className="form-group">
                <label>ë‚œì´ë„</label>
                <div className="difficulty-selector">
                  <button className={`diff-btn ${difficulty === 'easy' ? 'active' : ''}`} onClick={() => setDifficulty('easy')}>
                    <span className="diff-icon">ğŸ˜Š</span><span className="diff-name">ì‰¬ì›€</span><span className="diff-desc">10Ã—10, ê°€ë¡œ/ì„¸ë¡œ</span>
                  </button>
                  <button className={`diff-btn ${difficulty === 'hard' ? 'active' : ''}`} onClick={() => setDifficulty('hard')}>
                    <span className="diff-icon">ğŸ”¥</span><span className="diff-name">ì–´ë ¤ì›€</span><span className="diff-desc">15Ã—15, ëŒ€ê°ì„ +ì—­ë°©í–¥</span>
                  </button>
                </div>
              </div>
              <button className="generate-btn" onClick={generatePuzzle}>âœ¨ í¼ì¦ ìƒì„±í•˜ê¸°</button>
              {puzzleCode && (
                <div className="url-result">
                  <h3>ğŸ‰ í¼ì¦ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!</h3>
                  <div className="result-section">
                    <label>ğŸ“ í•™ìƒ ë°°í¬ìš© ë§í¬</label>
                    <div className="url-box">
                      <input type="text" value={generatedUrl} readOnly className="url-input" />
                      <button className="copy-btn" onClick={copyUrl}>ë³µì‚¬</button>
                    </div>
                  </div>
                  <div className="action-buttons">
                    <button className="preview-btn" onClick={() => { setPuzzleData(decodeData(puzzleCode)); setMode('play'); setIsPreviewMode(true); setShowAnswers(false); }}>ğŸ‘€ ë¯¸ë¦¬ë³´ê¸°</button>
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      }

      if (mode === 'play' && grid.length > 0) {
        const wordsToFind = placements.map(p => p.word);
        const gridSize = grid.length;
        const wsComplete = foundWords.length === placements.length;
        const matchComplete = puzzleData.words.every(w => matchingAnswers[w.english.toUpperCase()]);

        return (
          <div className="app-container">
            <Confetti active={resultData?.isPerfect} />
            {showResult && resultData && (
              <div className="result-modal">
                <div className="result-content">
                  <div className="result-icon">{resultData.isPerfect ? 'ğŸ‰' : 'ğŸ“'}</div>
                  <h2>{resultData.isPerfect ? 'ì™„ë²½í•´ìš”!' : 'ì±„ì  ê²°ê³¼'}</h2>
                  <p className="result-score">ì ìˆ˜: {resultData.score}ì </p>
                  <div className="result-details">
                    <p>â±ï¸ ì†Œìš” ì‹œê°„: {formatTime(resultData.time)}</p>
                    <p>ğŸ” ë‹¨ì–´ ì°¾ê¸°: {resultData.wordSearchCorrect} / {resultData.wordSearchTotal}</p>
                    <p>ğŸ”— ëœ» ì—°ê²°: {resultData.matchingCorrect} / {resultData.matchingTotal}</p>
                    {resultData.wrongAnswers.length > 0 && (
                      <div className="wrong-list">
                        <h4>âŒ í‹€ë¦° ë¬¸ì œ</h4>
                        {resultData.wrongAnswers.map((item, i) => (
                          <div key={i} className="wrong-item">
                            <strong>{item.english}</strong><br/>
                            ë‚´ ë‹µ: {item.userAnswer}<br/>
                            ì •ë‹µ: <span style={{color: '#6BCB77'}}>{item.correctAnswer}</span>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <div className="result-buttons">
                    {!resultData.isPerfect && <button className="retry-btn" onClick={retryWrong}>ğŸ”„ ë‹¤ì‹œ í’€ê¸°</button>}
                    <button className="play-again-btn" onClick={resetGame}>ğŸ†• ìƒˆë¡œ ì‹œì‘</button>
                    <button className="home-btn-small" onClick={() => { window.history.pushState({}, '', window.location.pathname); setMode('home'); setPuzzleData(null); setIsPreviewMode(false); setShowAnswers(false); }}>ğŸ  í™ˆìœ¼ë¡œ</button>
                  </div>
                </div>
              </div>
            )}
            <div className="play-screen">
              <div className="play-header">
                <h2 className="puzzle-title">{puzzleData?.title || 'ì˜ì–´ ë‹¨ì–´ í•™ìŠµ'}</h2>
                <div className="timer">â±ï¸ {formatTime(timer)}</div>
              </div>
              
              {isPreviewMode && (
                <div className="teacher-controls">
                  <span className="teacher-badge">ğŸ‘©â€ğŸ« êµì‚¬ ë¯¸ë¦¬ë³´ê¸°</span>
                  <button className={`answer-toggle-btn ${showAnswers ? 'active' : ''}`} onClick={() => setShowAnswers(!showAnswers)}>
                    {showAnswers ? 'ğŸ™ˆ ì •ë‹µ ìˆ¨ê¸°ê¸°' : 'ğŸ‘ï¸ ì •ë‹µ ë³´ê¸°'}
                  </button>
                </div>
              )}
              <div className="section-box" style={{marginTop: 0, marginBottom: '1rem'}}>
                <h3>ğŸ” ë‹¨ì–´ ì°¾ê¸° <span className={`status-badge ${wsComplete ? 'complete' : 'incomplete'}`}>{wsComplete ? 'ì™„ë£Œ!' : `${foundWords.length}/${wordsToFind.length}`}</span></h3>
              </div>
              <div className="grid-wrapper">
                <div className={`grid-container ${wrongSelection ? 'shake' : ''} size-${gridSize}`} style={{ gridTemplateColumns: `repeat(${gridSize}, 1fr)` }} ref={gridRef} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchEnd={handleMouseUp}>
                  {grid.map((row, y) => row.map((cell, x) => {
                    const color = getFoundColor(x, y);
                    return (
                      <div key={`${x}-${y}`} className={`grid-cell ${isCellSelected(x, y) ? 'selected' : ''} ${color ? 'found' : ''}`} style={color ? { backgroundColor: color } : {}}
                        onMouseDown={() => handleCellMouseDown(x, y)} onMouseEnter={() => handleCellMouseEnter(x, y)}
                        onTouchStart={(e) => { e.preventDefault(); handleCellMouseDown(x, y); }}
                        onTouchMove={(e) => { e.preventDefault(); const el = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY); if (el?.dataset.x) handleCellMouseEnter(+el.dataset.x, +el.dataset.y); }}
                        data-x={x} data-y={y}>{cell}</div>
                    );
                  }))}
                </div>
              </div>
              <div className="section-box">
                <h3>ì°¾ì•„ì•¼ í•  ë‹¨ì–´</h3>
                <div className="words">{wordsToFind.map((word, i) => (<span key={i} className={`word-item ${foundWords.includes(word) ? 'found' : ''}`}>{word}</span>))}</div>
              </div>
              <div className="section-box">
                <h3>ğŸ”— ëœ» ì—°ê²°í•˜ê¸° <span className={`status-badge ${matchComplete ? 'complete' : 'incomplete'}`}>{matchComplete ? 'ì™„ë£Œ!' : `${Object.keys(matchingAnswers).length}/${puzzleData.words.length}`}</span></h3>
                {puzzleData.words.map((word, i) => {
                  const key = word.english.toUpperCase();
                  const checked = checkedAnswers.hasOwnProperty(key);
                  const correct = checkedAnswers[key];
                  return (
                    <div key={i} className={`matching-row ${checked ? (correct ? 'correct' : 'incorrect') : ''} ${showAnswers ? 'show-answer' : ''}`}>
                      <div className="english-word">{word.english}</div>
                      <span className="arrow-icon">â†’</span>
                      <select className={`meaning-select ${checked ? (correct ? 'correct' : 'incorrect') : ''}`} value={matchingAnswers[key] || ''} onChange={(e) => handleMatchingChange(key, e.target.value)} disabled={checked && correct}>
                        <option value="">ëœ»ì„ ì„ íƒí•˜ì„¸ìš”</option>
                        {shuffledMeanings.map((m, j) => <option key={j} value={m}>{m}</option>)}
                      </select>
                      {checked && !correct && <div className="correct-answer">ì •ë‹µ: {word.korean}</div>}
                      {showAnswers && !checked && <div className="correct-answer">ğŸ’¡ ì •ë‹µ: {word.korean}</div>}
                    </div>
                  );
                })}
              </div>
              <div className="submit-section">
                {!isAllComplete() && <p className="incomplete-warning">âš ï¸ ëª¨ë“  í™œë™ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”!</p>}
                <button className="submit-btn" onClick={checkAnswers} disabled={!isAllComplete()}>âœ… í™œë™ ì¢…ë£Œ & ì±„ì í•˜ê¸°</button>
              </div>
              <button className="reset-btn" onClick={resetGame}>ğŸ”„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘</button>
            </div>
          </div>
        );
      }
      return <div className="app-container"><div className="loading">ë¡œë”© ì¤‘...</div></div>;
    }
    ReactDOM.createRoot(document.getElementById('root')).render(<EduPuzzleMaker />);
  </script>
</body>
</html>
